#Mapping_Data 仕様メモ

●未実装
・offsetの自動取得
→PTUデータの冒頭にフラグとなる時刻を入れておき，PTUデータを2行目以降のものを読み込む．また，LMm-Gデータのフラグの閾値だけ決めれるようにする．フラグを抜けるまでの時間も考慮すること．
・LMm-Gデータをそのまま読み込む
→何行目以降読み込んでいくようにする
・複数計測に対応する
→計測範囲を設定できるようにする
・複数のCSVファイルの読み込み，結合
→PTUのプログラムのほうも修正が必要？同期をどうやるか＝計測範囲との兼ね合い
・temp_len
→リストにする？

●仕様（変数の意味合い等）
＜PTU座標とボクセル座標の変換＞
・ボクセル座標 = PTU座標/delta
・PTU座標 = ボクセル座標*delta

＜大域変数＞
・Xrange,Yrange,Zrange: 各方向のセルの数＝ボクセル座標の最大値
・cell_size: すべてのセルの数
・measure_num: 計測点の総数＝Length_List（時間同期したデータの数）と同じ数になっているはず
・temp_len: 一本の光路の分割数（仮）
・INTERSECTION：交点情報を格納する構造体
・split_OP: 最終的に欲しいもの！配列[計測回，ボクセルナンバー]=OP

＜各関数での処理＞
【Main関数】
・split_OPの初期化（すべて0にしておいて，値があるところだけ後で代入する方針）
・同期データの取得＝PTU_Pan,PTU_Tilt,LMm_Measureのリストが得られる
・create_VOXCEL_num(): ボクセルナンバーをふる
・CalOP(PTU_Pan[i], PTU_Tilt[i], i): i番目の計測の分割光路長の計算

【CalOP(int pan, int tilt, int MEASURE_NUMBER)】
→一本の分割光路を求めるもの
・MEASURE_NUMBER: 何番目の計測か
・角度の設定
> pan,tilt: 生データ[position]（PTU本体角度とPTU座標はプラマイが逆転している）
> deg_tilt: 計算に使う角シータ[deg]（プラマイ反転させて，degに直して，90度から引く）
> deg_pan: 計算に使う角ファイ[deg]（phi>=0,phi<0で場合分けして，x軸からの角度を入れている）
> rad_pan, rad_tilt: 実際の計算で使うための角度[rad]
・intersection_grid[i]: 交点情報を入れる構造体，iは分割番号，初期化する
・x_loop, y_loop, z_loop: ループ用変数
・分割点を求めるループ
>> phi>=0のとき
> ループの開始点は1(=delta/delta)と仮定（phi>=0より）
> xmin>0ならループの開始点を変更（phi>=0より負の場合は考慮しない）
> x走査：x>=0の範囲で走査している，ボクセルナンバーはここで座標から取得
>> phi<0のとき
> ループの開始点は1と仮定．※xについては絶対値で考えている！（座標の正負についてはあとの計算で考慮する！）
> xmax<0ならループの開始点を変更（phi<0より正の場合は考慮しなくてよい）
> x走査：注）x_loopは正の値でまわっている
> phiの正負での場合分けおよび，xを絶対値で考えているので，y,zのグリッド座標はphi>0の場合と同じでよい
> ただし，x_gridだけ最後に負にしておく必要がある
・原点からの長さでソート
・原点からの長さの差分で分割光路を計算
・値を最終配列split_OPに入れる 

【ボクセルナンバー取得関係】
・get_VOXEL_num: 交点座標をまるめてボクセル座標に変換し，そのボクセル座標からボクセルナンバーを取得する関数（入力：PTU座標，出力：ボクセルナンバー）
・trans_Voxel_num: ボクセル座標からボクセルナンバーを取得する
・create_VOXCEL_num: 事前にすべてのボクセルにボクセルナンバーを振っておく（ボクセルの初期化）
